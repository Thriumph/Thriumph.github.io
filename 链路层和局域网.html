<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head><meta name="generator" content="Hexo 3.9.0">
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      链路层和局域网 | Thriumph
    
  </title>
  <meta name="author" content="Thriumph">
  <meta name="keywords" content="pwn,re,渗透测试">
  <meta name="description" content="不将就、不妥协、不停留">
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  <link rel="stylesheet" href="/css/Annie.css">
  
  <!-- jquery -->
	<script src="/plugin/jquery/jquery.min.js"></script>

<script>
    const CONFIG_BGIMAGE = {
      mode: 'normal',
      normalSrc: 'https://source.unsplash.com/collection/954550/1920x1080',
      randomYouMax: 110,
      randomYouSrc: '/',
	  randomOtherSrc: '/',
	  preloaderEnable: true
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: true,
	  appId: 'kL7JiFr2neE843z5adAoDHih-gzGzoHsz',
	  appKey: 'AsJ5lg1K8yyk6Rdo39i5dX1h',
	  serverURLs: 'http' || ' '
    }
  </script>
</head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground bg-pan-br">
	<div class="mask">
		<!-- motto -->
		<div class="h-body">	
			
				<div class="motto text-shadow-pop-left">
					<p class="content" id="motto-content">获取中...</p>
					<p>-<p>
					<p class="author" id="motto-author">Just a minute...</p>
				</div>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「链路层和局域网」
		
	</p>

	
	
		<span id="star-button" rel="unlike">
			<i class="icon-heart"></i>
		</span>
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<span class="logo"> 
			<img src="/img/logo.png">
		</span>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-one"><span class="path1"></span><span class="path2"></span></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-zhihu"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-sina-weibo "></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-pinterest2"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-instagram"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-twitter"></span>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<span class="icon-rss"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		<script src="/plugin/toc/katelog.min.js"></script>

		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/链路层和局域网.html" itemprop="url">
		链路层和局域网
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/链路层和局域网.html" itemprop="url">
		<time datetime="2019-06-15T16:03:40.000Z" itemprop="dateUpdated">
	  		2019-10-22
	  </time>
	</a> 



			</span>
			<span>
				
	<i class="icon-price-tags"></i>
	
		<a href="/tags/读书笔记/" class=" ">
			读书笔记
		</a>
	
		<a href="/tags/计算机网络/" class=" ">
			计算机网络
		</a>
	
		
			</span>
			
			

	
    <span class="leancloud_visitors" id="/链路层和局域网.html_visitors" data-url="/链路层和局域网.html" data-title="链路层和局域网">
       	<i class="icon-eye"></i>
       	热度
        
            <i class="leancloud_visitors_count" id="leancloud_visitors_count">1</i>
                   
    </span>
    



	
    <span class="leancloud_likes" id="/链路层和局域网.html_likes" data-url="/链路层和局域网.html" data-title="链路层和局域网" rel="unlike">
        <i class="icon-heart"></i>
        喜欢
        <i class="leancloud_likes_count" id="leancloud_likes_count">0</i>
    </span>
	

		</div>

		<div class="article-content" id="article-content">
			<p>《计算机网络自顶向下方法》第六章读书笔记</p>
<a id="more"></a>

<p><code>链路层信道分为两种：</code></p>
<p><code>广播信道</code>:局域网,无限LAN,卫星和混合光纤</p>
<p><code>点对点的通信链路</code></p>
<h1 id="链路层的概念"><a href="#链路层的概念" class="headerlink" title="链路层的概念"></a>链路层的概念</h1><p>运行链路层协议的任何设备称为<code>节点</code>。把沿着通信路径连接相邻节点的通信信道称为<code>链路</code></p>
<p>链路层采取的动作包括了差错检测,重传,流量控制以及随机接入</p>
<p><code>特点:</code>数据报在不同的链路可以使用不同的协议</p>
<h2 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h2><p><code>成帧:</code>在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数字字段和若干首部字段组成，其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定。</p>
<p><code>链路接入:</code>媒体访问控制协议（Medium Access Control, MAC）协议规定了帧在链路上传输的规则。</p>
<p><code>可靠交付:</code>当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。</p>
<p><code>差错检测和纠正:</code>当帧中的一个比特作为1传输时，接收方节点中的链路层硬件可能不正确地将其判断为0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送节点在帧中包含差错检测比特，让接收节点进行差错检查，以此来完成这项工作。</p>
<h2 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h2><p>链路层的主体部分是在 <strong>网络适配器</strong> 中实现的，网络适配器有时也称为 <strong>网络接口卡</strong> ，位于适配器核心的是链路层控制器，这个控制器是实现许多链路层服务的专用芯片。链路层控制器的许多功能使用硬件是实现的。</p>
<p><img src="/链路层和局域网/1.png" alt></p>
<h1 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h1><p>在发送节点，为了保护比特免受差错，使用 <strong>差错检测和纠正比特（Error-Detection and-Correction, EDC）</strong> 来增强数据D。通常，要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报，而且包括链路帧首部中的链路的寻址信息、序号和其他字段。链路级中的D和EDC都被发送到接收节点</p>
<h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><code>奇偶校验</code>使用单个奇偶校验位。假设要发送的信息D有d比特。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这d + 1比特中1的总数是偶数。对于奇校验方案，选择校验比特值使得有奇数个1。接收方只需要数一数接收的d + 1比特中1的数目即可。如果在采用偶校验方案中发现了奇数个值为1的比特，接收方知道出现了奇数个比特差错。</p>
<p><code>二维奇偶校验</code>方案中，D中的d个比特被划分为i行j列。对每行和每列计算奇偶值。产生的i + j + 1奇偶比特构成了链路层帧的差错检测比特。包含比特值改变的列和行的校验值都将会出现差错。因此接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用存在就校验差错的列和行的索引来实际识别发生差错的比特并纠正它。</p>
<h2 id="校验和方法"><a href="#校验和方法" class="headerlink" title="校验和方法"></a>校验和方法</h2><p><code>检验和</code> 技术中，数据的字节作为16比特的整数对待并求和。这个和的反码形成了携带在报文段首部的因特网检验和。接收方通过对接收的数据的和取反码，并且检测其结果是否全为1比特来检测检验和。如果这些比特中有任何比特是0，就可以指示出差错。</p>
<h2 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h2><p>现今的计算机网络中广泛应用的差错检测技术基于<code>循环冗余检测（Cyclic Redundancy Check, CRC）</code>。CRC编码也称为多项式编码，因为该编码能够将要发送的比特串看作为系数是0和1一个多项式，对比特串的操作被解释为多项式算术。</p>
<p>​假设发送节点要发送一个d比特的数据D给接收节点。发送方和接收方首先必须协商一个r + 1比特模式，称为生成多项式，将其表示为G。要求G的最高有效比特是1。对于一个给定的数据段D，发送方要选择r个附加比特R，并将它们附加到D上，使得得到的d + r比特模式用模2算术恰好能被G整除。接收方用G去除接收到的d + r比特。如果余数非0，接收方知道出现了差错；否则认为数据正确而被接收。</p>
<p>​<code>求附加比特R的公式:</code></p>
<p><img src="/链路层和局域网/2.png" alt></p>
<p>其中remainder表示求余数。</p>
<p>国际标准定义的32比特生成多项式为</p>
<p>GCRC-32 = 100000100110000010001110110110111</p>
<p>每个CRC标准都能检测小于r + 1比特的突发差错。此外，在适当的假设下，长度大于r + 1比特的突发差错以概率1 – 0.5r被检测到。每个CRC标准也都能检测任何奇数个比特差错。</p>
<p>​    </p>
<h1 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h1><p>有两种类型的网络链路：<code>点对点链路</code>和<code>广播链路</code>。点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议（point-to-point protocol, PPP）和高级数据链路控制（high-level data link control, HDLC）就是两种这样的协议。广播链路能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。</p>
<p><code>对于速率为R bps的广播信道，多路访问协议应该具有以下所希望的特性：</code></p>
<ul>
<li>当仅有一个节点发送数据时，该节点具有R bps的吞吐量；</li>
<li>当有M个节点发送数据时，每个节点吞吐量为R/M bps的平均传输速率；</li>
<li>协议是分散的，即不会因某节点故障而使整个系统崩溃；</li>
<li>协议是简单的，使实现不昂贵。</li>
</ul>
<h2 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h2><p><code>多路访问协议有三种：</code></p>
<ul>
<li>信道划分协议</li>
<li>随机接入协议</li>
<li>轮流协议</li>
</ul>
<p>​假设一个支持N个节点的信道且信道的传输速率为R bps。TDM将时间划分为时间帧，并进一步划分每个时间帧为N个时隙。然后把每个时隙分配给N个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的TDM帧中指派给它的时隙内传输比特。TDM使每个节点在每个帧时间内得到了专用的传输速率，R/N bps。然而它由两个主要缺陷。首先，节点被限制于R/N bps的平均速率，即使当它是唯一有分组要发送的节点时。其次，节点必须总是等待它在传输序列中的轮次</p>
<p> FDM将R bps信道划分为不同的频段，并把每个频率分配给N个节点中的一个。因此FDM在较大的R bps信道中创建了N个较小的R/N bps信道。FDM避免了碰撞，在N个节点之间公平地划分了带宽。然而限制一个节点只能使用R/N的带宽，即使当它是唯一一个有分组要发送的节点时</p>
<p>​CDMA对每个节点分配一种不同的编码。然后每个节点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，CDMA网络具有一种特性，即不同的节点能够同时传输，并且它们各自相应的接收方仍能正确接收发送方编码的数据比特，而不在乎其他节点的干扰传输。</p>
<h2 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h2><p>在随机接入协议中，一个传输节点总是以信道的全部速率进行发送。当有碰撞时，设计碰撞的每个节点反复地重发它的帧，到该帧无碰撞地通过为止。但是当一个节点经历一次碰撞时，它不必立即重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个节点独立地选择随机时延。因为该随机实验是独立地选择的，所以下述现象是有可能的：这些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出</p>
<h3 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h3><p><code>时隙ALOHA假设:</code></p>
<ul>
<li>所有帧由L比特组成。</li>
<li>时间被划分成长度为L/R秒的时隙（这就是说，一个时隙等于传输一帧的时间）。</li>
<li>节点只是在时隙起点开始传输帧。</li>
<li>节点是同步的，每个节点都知道时隙何时开始。</li>
<li>如果在一个时隙中有两个或者更多个帧碰撞，则所有节点在该时隙结束之前检测到该碰撞事件。</li>
</ul>
<p><code>令p是一个概率，即一个在0和1之间的数。在每个节点中，时隙ALOHA的操作是</code></p>
<ul>
<li>当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</li>
<li>如果没有碰撞，该节点成功地传输它的帧，从而不需要考虑重传该帧。</li>
<li>如果有碰撞，该节点在时隙结束之前检测到这次碰撞。该节点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</li>
</ul>
<h4 id="时隙ALOHA的优点"><a href="#时隙ALOHA的优点" class="headerlink" title="时隙ALOHA的优点"></a>时隙ALOHA的优点</h4><ul>
<li>当某节点是唯一活跃的节点时，时隙ALOHA允许该节点以全速R连续传输。时隙ALOHA也是高度分散的，因为每个节点检测碰撞并独立地决定什么时候重传。但是，当有N个活跃节点时，时隙ALOHA的效率是Np(1 – p)N – 1，这个表达式的最大值仅为1/e = 0.37。也就是说，当有大量活跃用户时，时隙ALOHA的最大效率只有37%。</li>
<li>时隙ALOHA协议要求所有的节点同步它们的传输，以在每个时隙开始时开始传播。在纯ALOHA中，当一帧首次到达，节点将立即以概率p重传该帧，否则，该节点等待一个帧传输时间。在此等待之后，它则以概率p传输该帧，或者以概率1 – p在另一个帧时间等待。纯ALOHA的最大效率仅为1/(2e)，这刚好是时隙ALOHA的一半</li>
</ul>
<h3 id="载波监听多路访问（CSMA）"><a href="#载波监听多路访问（CSMA）" class="headerlink" title="载波监听多路访问（CSMA）"></a>载波监听多路访问（CSMA）</h3><p><code>载波侦听。</code>即一个节点在传输前先听信道。如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。（说话之前监听）</p>
<p><code>碰撞检测。</code>CSMA没有进行碰撞检测；即使已经出现了碰撞。而CSMA/CD进行碰撞检测。碰撞检测，即当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时时传输”循环之前等待一段随机时间。（如果与他人同时说话，停止说话）</p>
<p>广播信道的端到端 <strong>信道传播时延</strong> 在决定性能的反面决定关键的作用，传播时延越长，载波监听节点不能侦听到网络到另一个节点已经传输的机会越大。</p>
<h3 id="具有碰撞的载波监听多路访问（CSMA-CD）"><a href="#具有碰撞的载波监听多路访问（CSMA-CD）" class="headerlink" title="具有碰撞的载波监听多路访问（CSMA/CD）"></a>具有碰撞的载波监听多路访问（CSMA/CD）</h3><h4 id="CSMA-CD的运行步骤"><a href="#CSMA-CD的运行步骤" class="headerlink" title="CSMA/CD的运行步骤"></a>CSMA/CD的运行步骤</h4><ul>
<li>适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中。</li>
<li>如果适配器侦听到信道空闲，它开始传输帧。在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。</li>
<li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li>
<li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输。</li>
<li>中止传输后，适配器等待一个随机时间量，然后返回步骤2。</li>
</ul>
<h4 id="CSMA-CD效率"><a href="#CSMA-CD效率" class="headerlink" title="CSMA/CD效率"></a>CSMA/CD效率</h4><p>CSMA/CD使用 <strong>二进制指数后退算法</strong> ，使得当碰撞节点数量较少时，节点等待的时间间隔较短；当碰撞节点数量较大时，时间间隔较长。当传输一个给定帧时，在该帧经历了一连串n此碰撞后，节点随机地从{0, 1, 2, …, 2n – 1}中选择一个K值。因此，一个帧经历的碰撞越多，K选择的间隔越大。对于以太网，一个节点等待实际时间量是K ∙ 512比特时间（即发送512比特进入以太网所需的时间量的K倍，n能够取的最大值为10。</p>
<p>CSMA/CD效率定义：当有大量的活跃节点，且每个节点有大量帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。令dprop表示信号能量在任意两个适配器之间传播所需的最大时间。令dtrans表示传输一个最大长度的以太网帧的时间。则CSMA/CD的效率为</p>
<p><img src="/链路层和局域网/3.png" alt></p>
<h2 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h2><p><code>轮流协议主要有两种：轮询协议和令牌传递协议。</code></p>
<h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><p>轮询协议要求节点之一要被指定为主节点。主节点以循环的方式轮询每个节点。轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得高得多的效率。但是它也有一些缺点。第一，该协议引入了轮询时延，即通知一个节点“它可以传输”所需的时间。第二，如果主节点有故障，整个信道都变得不可操作。</p>
<h3 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h3><p>令牌传递协议中没有主节点。一个成为令牌的小的特殊帧在节点之间以某种固定的次序进行交换。当一个节点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌，并发送最大数目的帧数，然后把令牌转发给下一个节点；否则它立即向下一个节点转发该令牌。令牌传递是分散的，并有很高的效率。但是一个节点的故障可能会使整个信道崩溃。或者如果一个节点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p>
<h2 id="DOCSIS：用于电缆因特网接入的链路层协议"><a href="#DOCSIS：用于电缆因特网接入的链路层协议" class="headerlink" title="DOCSIS：用于电缆因特网接入的链路层协议"></a>DOCSIS：用于电缆因特网接入的链路层协议</h2><p>一个电缆接入网通常在电缆网头端将几千个住宅电缆调制解调器与一个电缆调制解调器端接系统（Cable Modem Termination System, CMTS）连接。数据经电缆服务接口（Data-Over-Cable Service Interface, DOCSI）规范（DOCSIS）定义了电缆数据网络体系结构及其协议。</p>
<h1 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h1><p><img src="/链路层和局域网/4.png" alt></p>
<h2 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h2><p><strong>地址解析协议（ARP）</strong> 提供了将IP地址转换为链路层地址的协议</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>1.主机或路由器的适配器（即网络接口）具有链路层地址。链路层地址有各种不同的称呼：LAN地址、物理地址或MAC（Medium Access Control）地址。MAC地址是最为流行的术语。</p>
<p>2.没有两块适配器具有相同的地址。适配器的MAC地址具有扁平结构，而且不论适配器到哪里用都不会变化。</p>
<p>3.MAC地址的长度为6字节，共有6的48次方的可能的MAC地址，6个字节的地址常用16进制表示法，地址的每个字节表示一对十六进制数</p>
<h4 id="主机和路由器接口除了网络层地址之外还有MAC地址的原因"><a href="#主机和路由器接口除了网络层地址之外还有MAC地址的原因" class="headerlink" title="主机和路由器接口除了网络层地址之外还有MAC地址的原因"></a>主机和路由器接口除了网络层地址之外还有MAC地址的原因</h4><ul>
<li>局域网是为任意网络层协议而设计的，而不只是用于IP和因特网。</li>
<li>如果适配器使用网络层地址而不是MAC地址的话，网络层地址必须存储在适配器的RAM中，并且在每次适配器移动时要重新配置。</li>
</ul>
<p><img src="/链路层和局域网/5.png" alt></p>
<h3 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h3><p>1.<code>地址解析协议（Address Resolution Protocol, ARP）</code>用于在网络层地址（比如因特网的IP地址）和链路层地址(MAC地址)之间进行转换。ARP只为在同一个子网上的主机和路由器接口解析IP地址。</p>
<p><img src="/链路层和局域网/6.png" alt></p>
<p>2.每台主机或路由器在其内存中具有一个ARP表，这张表包含IP地址到MAC地址的映射关系。该ARP表也包含一个寿命值，它指示了从表中删除每个映射的时间。</p>
<p>3.假定主机A要向主机B发送一个数据报，该数据报要IP寻址到本子网上另一台主机或路由器。发送主机需要获得给定IP地址的目的主机的MAC地址。如果发送方的ARP表具有该目的节点的表项，则直接通过查询ARP表即可完成任务。如果ARP表中当前没有该目的主机的表项，发送方构造一个称为ARP分组的特殊分组。一个ARP分组有几个字段，包括发送和接收IP地址及MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址</p>
<p><img src="/链路层和局域网/7.png" alt></p>
<p>4.查询ARP报文是在广播帧中发送的，而响应ARP报文在一个标准帧中发送。ARP是即插即用的，即一个ARP表是自动建立的，它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的节点的表中删除掉。</p>
<h4 id="ARP协议原理"><a href="#ARP协议原理" class="headerlink" title="ARP协议原理"></a>ARP协议原理</h4><p>1.如果要通过IP来得到同一子网上的主机MAC地址；过程是这样的：首先源主机会看看自己的ARP机制的内存里有没有对应的IP MAC项，有就直接输出目标MAC地址；没有的话就需要ARP发送一个查询分组，分组以广播的形式发送，也就是每一个主机都能收到这个查询分组，收到之后，各个被询问的主机会先看看 目标IP是不是与自己的IP对应，不对应就不用响应，对应的就应该返回一个响应分组。这样源主机的ARP机制就有了目的IP地址的MAC地址了。</p>
<p>2.通过目标IP获得子网以外的主机的MAC地址；首先，源主机有了目的主机的IP地址，假想我们通过某种手段已经得到了目的主机的MAC地址了，那现在是不是就可以直接放入数据帧里面呢，显然是不行的，因为目前看来，目的MAC地址与当前的任何一个路由的MAC地址都不匹配。任何路由都不会给与转发。事实上是这样的，我们有了目标IP地址，通过路由算法得到了最短路径的转发表，我们每一次转发不是直接用目标主机的IP地址的，而是用路由表中给出的每一跳的地址，这样，先得到通往外网的第一个路由的MAC地址，现在关键来了：由于在外网中路由器的一个IP对应一个MAC，他也是通过ARP查询得到与他匹配的IP再得到返回的MAC地址的。就这样得到外网路由的第二个MAC地址，这样直到终点</p>
<h3 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h3><p><img src="/链路层和局域网/8.png" alt></p>
<p>每台主机仅有一个IP地址和一个适配器，一台路由器对它的每个接口都有一个IP地址，也有一个ARP模块和一个适配器，每个适配器都有自己的MAC地址</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>1.如果某台主机要向子网外的另一台主机发送数据报，则发送主机必须首先发送给最终目的路径上的第一跳路由器</p>
<p>2.初始的以太网是使用总线拓扑的一种广播局域网，即所有的帧传送到与该总线连接的所有适配器并被其处理。</p>
<p>3.在20世纪90年代后期，大多数公司和大学使用一种基于集线器的星形拓扑以太网安装替代了它们的局域网。在这种安装中，主机和路由器直接用双绞对铜线与一台 <strong>集线器</strong> 相连。集线器是一种物理层设备，它作用于各个比特而不是作用于帧。当表示一个0或一个1的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。</p>
<p>4.在21世纪初，以太网又经历了一次重要的革命性变化。以太网安装继续使用星形拓扑，但是位于中心的集线器被 <strong>交换机</strong> 所替代。</p>
<h3 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h3><p><img src="/链路层和局域网/9.png" alt></p>
<p><code>太网帧有以下6个字段</code></p>
<ul>
<li><code>数据字段（46~1500字节）。</code>这个字段承载了IP数据报。以太网的最大传输单元是1500字节。这意味着如果IP数据报超过了1500字节，则主机必须将该数据报分片。数据字段的最小长度是46字节。这意味着如果IP数据报小于46字节，数据报必须被填充到46字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分。网络层使用IP数据报首部中的长度字段来去除填充部分。</li>
<li><code>目的地址（6字节）。</code>这个字段包含目的适配器的MAC地址。当适配器收到一个以太网帧，帧的目的地址如果和该适配器MAC地址相同或为广播地址，则它都将该帧的数据字段的内容传递给网络层；如果它受到了具有任何其他MAC地址的帧，则丢弃之。</li>
<li><code>源地址（6字节）。</code>这个地段包含了传输该帧到局域网上的适配器的MAC地址。</li>
<li><code>类型字段（2字节）。</code>类型字段允许以太网复用多种网络层协议。</li>
<li><code>CRC（4字节）。</code>CRC字段的目的时使得接收器检测帧中是否引入了差错。</li>
<li><code>前同步码（8字节）。</code>以太网帧以一个8字节的钱同步码字段开始。该前同步码的前7个字节的值都是10101010；最后一个字节时10101011。前同步码字段的前7字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特警告接收适配器，“重要的内容“就要到来了。</li>
</ul>
<h3 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h3><p>所有的以太网技术都向网络层提供无连接服务和不可靠服务。</p>
<h2 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h2><p>交换机自身对子网中的主机和路由器是透明的，某主机/路由器向另一个主机/路由器寻址一个帧（而不是向交换机寻址该帧），顺利将该帧发送进局域网，并不知道某交换机将会接收该帧并将该帧转发到另一个节点</p>
<h3 id="交换机的转发和过滤"><a href="#交换机的转发和过滤" class="headerlink" title="交换机的转发和过滤"></a>交换机的转发和过滤</h3><p><code>过滤</code>是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p>
<p><code>转发</code>是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。交换机的过滤和转发借助于<code>交换机表</code>完成。</p>
<p>该交换机表发函某局域网上某些主机和路由器的但不必是全部的表项。交换机表中的一个表项包含：一个MAC地址；通向该MAC地址的交换机接口；表项放置在表中的时间。</p>
<p><code>假定目的地址为A的帧从交换机接口x到达。交换机用地址A索引它的表。有3种可能的情况</code></p>
<ul>
<li>表中没有对于A的表项。在这种情况下，交换机向除接口x外的所有接口前面的输出缓存转发该帧的副本。换言之，如果没有对于目的地址的表项，交换机广播该帧。</li>
<li>表中有一个表项将A与接口x联系起来。在这种情况下，该帧从包括适配器A的局域网网段到来。无须将该帧转发到任何其他接口，交换机将通过丢弃该帧执行过滤功能即可。</li>
<li>表中有一个表项将A与接口y ≠ x联系起来。在这种情况下，该帧需要被转发到与接口y相连的局域网网段。交换机通过将该帧放到接口y前面的输出缓存完成转发功能。</li>
</ul>
<h3 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h3><p>交换机的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。即交换机的<code>自学习</code>的。这种能力是以如下方式实现的：<br>交换机表初始为空。</p>
<ul>
<li>对于在每个接口接受到的每个入帧，该交换机在其表中存储：在该帧源地址字段中的MAC地址；该帧到达的接口；当前时间。交换机以这种方式在它的表中记录了发送节点所在的局域网网段。</li>
<li>如果在一段时间（称为老化期）后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。</li>
</ul>
<h3 id="交换机的性质"><a href="#交换机的性质" class="headerlink" title="交换机的性质"></a>交换机的性质</h3><ol>
<li><p><strong>消除碰撞。</strong> 在使用交换机构建的局域网中，没有因碰撞而浪费的贷款。交换机缓存帧并且决定不会在网段上同时传输多余一个帧。因此，交换机提供了比使用广播链路的局域网高得多的性能改善。</p>
</li>
<li><p><strong>异质的链路。</strong> 交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速率并且能够在不同的媒体上运行。因此，对于原有的设备与新设备混用，交换机是理想的。</p>
</li>
<li><p><strong>管理。</strong> 除了提供强化的安全性，交换机也易于进行网络管理。</p>
</li>
</ol>
<h3 id="交换机和路由器比较"><a href="#交换机和路由器比较" class="headerlink" title="交换机和路由器比较"></a>交换机和路由器比较</h3><p>1.交换机是即插即用的；交换机能够具有相对高的分组过滤和转发速率；交换机必须处理高至第二层的帧，而路由器必须处理高至第三层的数据报；为了防止广播帧的循环，交换网络的活跃拓扑限制为一颗生成树。另外，一个大型交换网络将要求在主机和路由器中有大量的ARP表，这将生成客观的ARP流量和处理量。而且，交换机对于广播风暴并不提供任何保护措施。</p>
<p>2.因为网络殉职通常是分层次的，即使当网络中存在冗余路径时，分组通常也不会通过路由器循环。所以，分组不会被限制到一颗生成树上，并可以使用源和目的地之间的最佳路径。路由器对第二层的广播风暴提供了防火墙保护。路由器不是即插即用的，即路由器和连接到它们的主机都需要人为地配置IP地址。而且路由器对每个分组的处理时间通常比交换机更长，因为它们必须处理高达第三层的字段。</p>
<p><img src="/链路层和局域网/10.png" alt></p>
<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>现代机构的局域网配置为等级结构的，每个工作组都有自己的交换局域网，经过一个交换机等级与其他工作组交换局域网互联</p>
<p>三个缺点：</p>
<p>1.缺乏流量隔离</p>
<p>2.交换机的无效使用</p>
<p>3.管理用户</p>
<p><strong>可以用通过支持虚拟局域网（VLAN）的交换机来处理</strong></p>
<h1 id="链路虚拟化-网络作为链路层"><a href="#链路虚拟化-网络作为链路层" class="headerlink" title="链路虚拟化:网络作为链路层"></a>链路虚拟化:网络作为链路层</h1><h3 id="多协议标签交换（MPLS）"><a href="#多协议标签交换（MPLS）" class="headerlink" title="多协议标签交换（MPLS）"></a>多协议标签交换（MPLS）</h3><p>1.<code>多协议标签交换（Multiprotocol Label Switching, MPLS）</code>采用来自虚电路网络领域的一个关键概念：固定长度标签。其目标是：对于基于固定长度标签和虚电路的技术，在不放弃基于目的地IP数据报转发的基础设施的前提下，当可能时通过选择性地标识数据报并允许路由器基于固定长度的标签转发数据报来增强其功能。</p>
<p>2.在MPLS使能的路由器之间传输的一个链路层帧</p>
<p><img src="/链路层和局域网/11.png" alt></p>
<p>包括在MPLS首部中的字段是：</p>
<p>标签；</p>
<p>预留的3比特实验字段；</p>
<p>1比特S字段，用于指示一系列“成栈”的MPLS首部的结束；</p>
<p>寿命字段</p>
<p>3.一个MPLS加强的帧仅能在两个均为MPLS使能的路由器之间发送。一个MPLS使能的路由器常被称为标签交换路由器，因为它通过在其转发表中查找MPLS标签，然后立即将数据报传递给适当的输出接口来转发MPLS帧。因此，MPLS使能的路由器不需要提取目的IP地址和在转发表中执行最长前缀匹配的查找</p>
<p>4.MPLS能够并且已经被用于实现所谓虚拟专用网（Virtual Private Network, VPN）</p>
<h1 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h1><p>1.每个数据中心都有自己的数据中心网络，这些数据中心网络将其内部主机彼此互联并与因特网中的数据中心互联。数据中心中的主机称为<code>刀片</code>，一般是包括CPU、内存和磁盘存储的商用主机。主机被堆叠在机架上，每个机架一般堆放20~40台刀片。在每一个机架顶部有一台交换机，这台交换机形象地被称为机架<code>顶部（Top of Rank, TOR）交换机</code>，它们与机架上的主机互联，并与数据中心中的其他交换机互联。具体来说，机架上的每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。</p>
<p>2.数据中心网络支持两种类型的流量：在外部客户与内部主机之间流动的流量，以及内部主机之间流动的流量。为了处理外部客户与内部主机之间流动的流量，数据中心网络包括了一台或者多台<code>边界路由器</code>，它们将数据中心网络与公共因特网相连。数据中心网络因此需要将所有机架彼此互联，并将机架与边界路由器连接。</p>
<p>3.在数据中心内部，外部请求首先被定向到一个<code>负载均衡器</code>。负载均衡器的任务是向主机分发请求，以主机当前的负载作为函数来在主机之间均衡负载。一个大型数据中心通常会有几台负载均衡器，每台服务于一组特定的云引用。由于负载均衡器基于分组的目的端口号以及目的的IP地址做决策，因此它们常被称为“第四层交换机”。一旦接收到一个对于特定应用程序的请求，负载均衡器将该请求分发到处理该应用的某一台主机上。当主机处理完该请求后，向负载均衡器回送响应，再由负载均衡器将其中继发回给外部客户。负载均衡器不仅彭亨主机间的工作负载，而且还提供类似NAT的功能，将外部IP地址转换为内部适当主机的IP地址，然后将反方向流向客户的分组按照相反的转换进行处理。这防止客户直接接触主机，从而具有隐藏网络内部结构和防止客户直接与主机交互等安全益处。</p>
<p>4.数据中心网络的两个设计趋势是<code>全连接拓扑</code>和<code>模块化数据中心</code>。</p>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/无线网络和移动网络.html" title="无线网络和移动网络" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/网络层控制平面.html" title="网络层控制平面" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/计算机网络中的安全.html" title="计算机网络中的安全">
								计算机网络中的安全			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 20日, 2019				
							</p>
							<p class="relate-post-content">
								《计算机网络自顶向下方法》第八章读书笔记


什么是网络安全安全通信具有下列所需要的特性：
机密性。仅有发送方和希望的接收方能够理解传输报文的内容。因为窃听者可以截获报文，这必须要求报文在一定程度上进行加密，是截取的报文无法被截获者所...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/计算机网络中的安全.html" title="计算机网络中的安全">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="计算机网络中的安全"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/无线网络和移动网络.html" title="无线网络和移动网络">
								无线网络和移动网络			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 18日, 2019				
							</p>
							<p class="relate-post-content">
								《计算机网络自顶向下方法》第七章读书笔记


概述
基站 是无线网络基础设施的一个关键部分。基站在有线网络中没有明确的对应设备，它负责向与之关联的无线主机发送数据和从主机那里接收数据。基站通常负责协调与之相关联的多个无线主机的传输。当...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/无线网络和移动网络.html" title="无线网络和移动网络">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="无线网络和移动网络"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/网络层控制平面.html" title="网络层控制平面">
								网络层控制平面			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 14日, 2019				
							</p>
							<p class="relate-post-content">
								《计算机网络自顶向下方法》第五章读书笔记


概述计算、维护和安装转发表和流表有两种可能的方法：
1.每路由器控制。每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算转发表...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/网络层控制平面.html" title="网络层控制平面">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="网络层控制平面"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	
		<div class="config-info">
			Please check the parameter of <b>comment</b> in config.yml of hexo-theme-Annie!
		</div>	
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	 
	<script src="/plugin/clipboard/clipboard.js"></script>
	<script>
		// Copy code !
	    function preprocessing() {
	        $("#article-content .highlight").each(function() {
	            $(this).wrap('<div id="post-code"></div>');
	        })

	        $("#article-content #post-code").each(function() {
	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');
	        })

	        $("#article-content .copy-nav").each(function() {
	            let languageClass = $(this).next().attr('class'),
	                language = ((languageClass.length > 9) && (languageClass != null)) ? languageClass.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);
	            $(this).append('<span class="copy-btn icon-paste"></span>');
	        });
	    }

		function copy() {
		    $('#article-content #post-code').each(function(i) {
		        let codeCopyId = 'codeCopy-' + i;

		        let codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })
   
			let clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn icon-clipboard1');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn icon-paste');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');   
			});
			
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		}
		
		(function copyCode(){
			if ($('.layout-post').length) {
			    preprocessing();
			    copy();
			} 
		})();
	</script>





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
<script src="/plugin/fancybox/jquery.fancybox.js"></script>

<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
</ul>
	</div>

	<div class="copyright">
		<p>
			 
				&copy;2019 - 2020, content by Thriumph. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->

		
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	

		<span id="busuanzi_container_page_pv">
	  		本文总阅读量<span id="busuanzi_value_page_pv"></span>次
		</span>

	




			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- Local or hitokoto! -->

	<script src="/plugin/motto/motto.js"></script>
	
	<script type="text/javascript">
		(function motto(){
			let mottoText = getMingYanContent().split('</br> - </br>'),
			
			mottoTextContent = mottoText[0]?mottoText[0]:'请刷新...',
			
			mottoTextFrom = mottoText[1]?mottoText[1]:'one/一个';
			
			mottoTextContent = mottoTextContent.trim().substring(0, 100);
		
			$("#motto-content").html( mottoTextContent);
			$("#motto-author").html( mottoTextFrom  );
		})();	
	</script>	



<!-- love effect -->

	<script src="/plugin/love/love.js"></script>


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>



<!-- site analysis -->


	<!-- site-analysis -->
	
	<script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "//hm.baidu.com/hm.js?";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	
	<script src="//s6.cnzz.com/stat.php?id=&web_id=" type="text/javascript"></script>

	
	
	
 

<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


  <script src="/plugin/leancloud/av-min.js"></script>
<script src="/js/leancloud-count.js"></script>

	

  


<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>
	<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400,"hOffset":-20,"vOffset":80},"mobile":{"show":false}});</script></body>	
</html>